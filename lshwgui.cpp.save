#include <QApplication>
#include <QMainWindow>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QTabWidget>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QProcess>
#include <QProgressBar>
#include <QMessageBox>
#include <QHeaderView>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QDebug>
#include <QRegularExpression>
#include <QFile>
#include <QDir>
#include <QTextStream>
#include <QTextStream>
#include <QStorageInfo>

class LshwGUI : public QMainWindow
{
    Q_OBJECT

private:
    struct NetworkInfo {
        QString ipv4Address;
        QString ipv6Address;
        QString subnet;
        QString product;
        QString vendor;
        QString driver;
        bool isActive = false;
    };

public:
    LshwGUI(QWidget *parent = nullptr) : QMainWindow(parent)
    {
        setupUI();
        connectSignals();
        runLshw();
    }

private slots:
    void runLshw()
    {
        statusLabel->setText("Loading system information...");
        progressBar->setVisible(true);
        clearTables();
        loadOSInformation();
        
        QProcess *process = new QProcess(this);
        process->setProgram("lshw");
        process->setArguments({"-json"});
        
        connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                this, &LshwGUI::onLshwFinished);
        connect(process, &QProcess::errorOccurred, this, &LshwGUI::onLshwError);
        
        process->start();
    }
    
    void onLshwFinished(int exitCode, QProcess::ExitStatus exitStatus)
    {
        QProcess *process = qobject_cast<QProcess*>(sender());
        if (!process) return;
        
        progressBar->setVisible(false);
        
        if (exitStatus == QProcess::NormalExit && exitCode == 0) {
            QByteArray data = process->readAllStandardOutput();
            parseJsonData(data);
            statusLabel->setText("Hardware information loaded successfully");
        } else {
            runLshwFallback();
        }
        
        process->deleteLater();
    }
    
    void runLshwFallback()
    {
        statusLabel->setText("Trying alternative lshw format...");
        
        QProcess *process = new QProcess(this);
        process->setProgram("lshw");
        process->setArguments({"-short"});
        
        connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                this, &LshwGUI::onLshwFallbackFinished);
        
        process->start();
    }
    
    void onLshwFallbackFinished(int exitCode, QProcess::ExitStatus exitStatus)
    {
        QProcess *process = qobject_cast<QProcess*>(sender());
        if (!process) return;
        
        if (exitStatus == QProcess::NormalExit && exitCode == 0) {
            QByteArray data = process->readAllStandardOutput();
            parseShortFormat(data);
            statusLabel->setText("Hardware information loaded (short format)");
        } else {
            statusLabel->setText("Error: Could not run lshw. Make sure it's installed.");
            showErrorMessage();
        }
        
        process->deleteLater();
    }
    
    void onLshwError(QProcess::ProcessError error)
    {
        progressBar->setVisible(false);
        QString errorMsg;
        
        switch (error) {
            case QProcess::FailedToStart:
                errorMsg = "lshw failed to start. Make sure it's installed:\nsudo apt install lshw";
                break;
            case QProcess::Crashed:
                errorMsg = "lshw crashed during execution";
                break;
            default:
                errorMsg = "Unknown error occurred while running lshw";
                break;
        }
        
        statusLabel->setText("Error running lshw");
        QMessageBox::warning(this, "Error", errorMsg);
    }
    
    void onRefreshClicked() { runLshw(); }
    
    void onSearchTextChanged(const QString &text)
    {
        for (int tabIndex = 0; tabIndex < tabWidget->count(); ++tabIndex) {
            QTableWidget *table = qobject_cast<QTableWidget*>(tabWidget->widget(tabIndex));
            if (!table) continue;
            
            for (int row = 0; row < table->rowCount(); ++row) {
                bool shouldShow = text.isEmpty();
                
                if (!shouldShow) {
                    for (int col = 0; col < table->columnCount(); ++col) {
                        QTableWidgetItem *item = table->item(row, col);
                        if (item && item->text().contains(text, Qt::CaseInsensitive)) {
                            shouldShow = true;
                            break;
                        }
                    }
                }
                
                table->setRowHidden(row, !shouldShow);
            }
        }
    }

private:
    void setupUI()
    {
        setWindowTitle("Hardware Information Viewer (lshw GUI)");
        setMinimumSize(800, 500);  // Reduced minimum size
        
        // Set compact font for the entire application
        QFont compactFont("Helvetica", 8);
        QApplication::setFont(compactFont);
        
        QWidget *centralWidget = new QWidget(this);
        setCentralWidget(centralWidget);
        
        QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
        QHBoxLayout *toolbarLayout = new QHBoxLayout();
        
        refreshButton = new QPushButton("Refresh", this);
        refreshButton->setMaximumWidth(80);
        refreshButton->setFont(QFont("Helvetica", 8));
        refreshButton->setMaximumHeight(24);
        
        QLabel *searchLabel = new QLabel("Search:", this);
        searchLabel->setFont(QFont("Helvetica", 8));
        searchEdit = new QLineEdit(this);
        searchEdit->setPlaceholderText("Type to search hardware components...");
        searchEdit->setMaximumWidth(250);
        searchEdit->setFont(QFont("Helvetica", 8));
        searchEdit->setMaximumHeight(24);
        
        statusLabel = new QLabel("Ready", this);
        statusLabel->setFont(QFont("Helvetica", 8));
        progressBar = new QProgressBar(this);
        progressBar->setMaximumWidth(150);
        progressBar->setMaximumHeight(20);
        progressBar->setFont(QFont("Helvetica", 8));
        progressBar->setVisible(false);
        
        toolbarLayout->addWidget(refreshButton);
        toolbarLayout->addSpacing(20);
        toolbarLayout->addWidget(searchLabel);
        toolbarLayout->addWidget(searchEdit);
        toolbarLayout->addStretch();
        toolbarLayout->addWidget(statusLabel);
        toolbarLayout->addWidget(progressBar);
        
        mainLayout->addLayout(toolbarLayout);
        
        tabWidget = new QTabWidget(this);
        // Set compact styling for tabs
        tabWidget->setFont(QFont("Helvetica", 8));
        tabWidget->setStyleSheet("QTabWidget::pane { border: 1px solid #C0C0C0; }"
                                "QTabBar::tab { min-height: 18px; padding: 2px 8px; font-size: 8pt; }"
                                "QTabWidget { font-size: 8pt; }");
        mainLayout->addWidget(tabWidget);
        
        createHardwareTables();
    }
    
    void createHardwareTables()
    {
        osTable = createTable({"Property", "Value"});
        tabWidget->addTab(osTable, "Operating System");
        
        systemTable = createTable({"Property", "Value"});
        tabWidget->addTab(systemTable, "System");
        
        cpuTable = createTable({"Property", "Value", "Details"});
        tabWidget->addTab(cpuTable, "CPU");
        
        memoryTable = createTable({"Bank", "Size", "Type", "Speed", "Description"});
        tabWidget->addTab(memoryTable, "Memory");
        
        storageTable = createTable({"Device", "Size", "Type", "Model", "Description"});
        tabWidget->addTab(storageTable, "Storage");
        
        networkTable = createTable({"Interface", "Status", "IPv4 Address", "IPv6 Address", "Subnet", "Gateway", "Product", "Vendor", "Driver"});
        tabWidget->addTab(networkTable, "Network");
        
        allHardwareTable = createTable({"Class", "Device", "Product", "Vendor", "Description"});
        tabWidget->addTab(allHardwareTable, "All Hardware");
    }
    
    QTableWidget* createTable(const QStringList &headers)
    {
        QTableWidget *table = new QTableWidget(this);
        table->setColumnCount(headers.size());
        table->setHorizontalHeaderLabels(headers);
        
        // Apply compact styling
        table->setFont(QFont("Helvetica", 8));
        table->verticalHeader()->setDefaultSectionSize(18);  // Reduce row height
        table->horizontalHeader()->setFont(QFont("Helvetica", 8, QFont::Bold));
        table->horizontalHeader()->setDefaultSectionSize(80); // Compact column width
        table->horizontalHeader()->setStretchLastSection(true);
        
        table->setAlternatingRowColors(true);
        table->setSelectionBehavior(QAbstractItemView::SelectRows);
        table->setSortingEnabled(true);
        
        // Compact table styling
        table->setStyleSheet("QTableWidget { font-size: 8pt; gridline-color: #E0E0E0; }"
                            "QHeaderView::section { font-size: 8pt; font-weight: bold; padding: 2px; }");
        
        return table;
    }
    
    void connectSignals()
    {
        connect(refreshButton, &QPushButton::clicked, this, &LshwGUI::onRefreshClicked);
        connect(searchEdit, &QLineEdit::textChanged, this, &LshwGUI::onSearchTextChanged);
    }
    
    void clearTables()
    {
        osTable->setRowCount(0);
        systemTable->setRowCount(0);
        cpuTable->setRowCount(0);
        memoryTable->setRowCount(0);
        storageTable->setRowCount(0);
        networkTable->setRowCount(0);
        allHardwareTable->setRowCount(0);
    }
    
    void parseJsonData(const QByteArray &data)
    {
        QJsonParseError error;
        QJsonDocument doc = QJsonDocument::fromJson(data, &error);
        
        if (error.error != QJsonParseError::NoError) {
            qDebug() << "JSON parse error:" << error.errorString();
            parseShortFormat(data);
            return;
        }
        
        QJsonArray items;
        if (doc.isArray()) {
            items = doc.array();
        } else if (doc.isObject()) {
            items.append(doc.object());
        }
        
        processJsonItems(items);
    }
    
    void processJsonItems(const QJsonArray &items)
    {
        for (const QJsonValue &value : items) {
            if (!value.isObject()) continue;
            
            QJsonObject item = value.toObject();
            processJsonItem(item);
            
            if (item.contains("children")) {
                QJsonArray children = item["children"].toArray();
                processJsonItems(children);
            }
        }
    }
    
    void processJsonItem(const QJsonObject &item)
    {
        QString id = item["id"].toString();
        QString className = item["class"].toString();
        QString product = item["product"].toString();
        QString vendor = item["vendor"].toString();
        QString description = item["description"].toString();
        
        addRowToTable(allHardwareTable, {className, id, product, vendor, description});
        
        if (className == "system") {
            loadSystemInformation(item);
        } else if (className == "processor" || className == "cpu") {
            loadCpuInformation(item);
        } else if (className == "memory" || className == "bank") {
            loadMemoryInformation(item);
        } else if (className == "disk" || className == "storage") {
            loadStorageInformation(item);
        } else if (className == "network") {
            loadNetworkInformation(item);
        }
    }
    
    void loadSystemInformation(const QJsonObject &item)
    {
        addPropertyToTable(systemTable, "Product", item["product"].toString());
        addPropertyToTable(systemTable, "Vendor", item["vendor"].toString());
        addPropertyToTable(systemTable, "Version", item["version"].toString());
        addPropertyToTable(systemTable, "Serial", item["serial"].toString());
        
        if (item.contains("configuration")) {
            QJsonObject config = item["configuration"].toObject();
            for (auto it = config.begin(); it != config.end(); ++it) {
                addPropertyToTable(systemTable, "Config: " + it.key(), it.value().toString());
            }
        }
    }
    
    void loadCpuInformation(const QJsonObject &item)
    {
        QString details = QString("Cores: %1, Threads: %2")
                         .arg(item["configuration"].toObject()["cores"].toString())
                         .arg(item["configuration"].toObject()["threads"].toString());
        
        addRowToTable(cpuTable, {"Product", item["product"].toString(), details});
        addRowToTable(cpuTable, {"Vendor", item["vendor"].toString(), item["description"].toString()});
        
        if (item.contains("size")) {
            addRowToTable(cpuTable, {"Current Speed", 
                QString::number(item["size"].toDouble() / 1000000) + " MHz", ""});
        }
    }
    
    void loadMemoryInformation(const QJsonObject &item)
    {
        QString size = formatSize(item["size"].toDouble());
        QString description = item["description"].toString();
        
        addRowToTable(memoryTable, {
            item["slot"].toString(),
            size,
            item["product"].toString(),
            item["clock"].toString() + " MHz",
            description
        });
    }
    
    void loadStorageInformation(const QJsonObject &item)
    {
        QString size = formatSize(item["size"].toDouble());
        QString type = item["description"].toString();
        
        addRowToTable(storageTable, {
            item["logicalname"].toString(),
            size,
            type,
            item["product"].toString(),
            item["vendor"].toString()
        });
    }
    
    QMap<QString, NetworkInfo> getNetworkInterfaces()
    {
        QMap<QString, NetworkInfo> interfaces;
        
        // Get all network interfaces from /sys/class/net
        QDir netDir("/sys/class/net");
        QStringList interfaceNames = netDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot);
        
        for (const QString &interfaceName : interfaceNames) {
            if (interfaceName == "lo") continue; // Skip loopback
            
            NetworkInfo info;
            
            // Check if interface is up
            QFile operState(QString("/sys/class/net/%1/operstate").arg(interfaceName));
            if (operState.open(QIODevice::ReadOnly)) {
                QString state = operState.readAll().trimmed();
                info.isActive = (state == "up");
            }
            
            // Get IP addresses using ip command
            QProcess ipProcess;
            ipProcess.start("ip", QStringList() << "addr" << "show" << interfaceName);
            ipProcess.waitForFinished(2000);
            
            if (ipProcess.exitCode() == 0) {
                QString output = ipProcess.readAllStandardOutput();
                
                // IPv4 pattern
                QRegularExpression ipv4Regex(R"(inet (\d+\.\d+\.\d+\.\d+)/(\d+))");
                QRegularExpressionMatch ipv4Match = ipv4Regex.match(output);
                
                if (ipv4Match.hasMatch()) {
                    info.ipv4Address = ipv4Match.captured(1);
                    int prefixLength = ipv4Match.captured(2).toInt();
                    info.subnet = prefixLengthToSubnetMask(prefixLength);
                }
                
                // IPv6 pattern (global unicast addresses)
                QRegularExpression ipv6Regex(R"(inet6 ([0-9a-fA-F:]+)/(\d+) scope global)");
                QRegularExpressionMatch ipv6Match = ipv6Regex.match(output);
                
                if (ipv6Match.hasMatch()) {
                    info.ipv6Address = ipv6Match.captured(1);
                }
            }
            
            // Get hardware info using ethtool
            QProcess ethtoolProcess;
            ethtoolProcess.start("ethtool", QStringList() << "-i" << interfaceName);
            ethtoolProcess.waitForFinished(2000);
            
            if (ethtoolProcess.exitCode() == 0) {
                QString output = ethtoolProcess.readAllStandardOutput();
                QStringList lines = output.split('\n');
                
                for (const QString &line : lines) {
                    if (line.startsWith("driver: ")) {
                        info.driver = line.mid(8).trimmed();
                    }
                }
            }
            
            interfaces[interfaceName] = info;
        }
        
        return interfaces;
    }
    
    QString prefixLengthToSubnetMask(int prefixLength)
    {
        if (prefixLength < 0 || prefixLength > 32) return "Invalid";
        
        uint32_t mask = (0xFFFFFFFF << (32 - prefixLength)) & 0xFFFFFFFF;
        return QString("%1.%2.%3.%4")
            .arg((mask >> 24) & 0xFF)
            .arg((mask >> 16) & 0xFF)
            .arg((mask >> 8) & 0xFF)
            .arg(mask & 0xFF);
    }
    
    QString getDefaultGateway()
    {
        QProcess routeProcess;
        routeProcess.start("ip", QStringList() << "route" << "show" << "default");
        routeProcess.waitForFinished(2000);
        
        if (routeProcess.exitCode() == 0) {
            QString output = routeProcess.readAllStandardOutput();
            QRegularExpression gwRegex(R"(default via (\d+\.\d+\.\d+\.\d+))");
            QRegularExpressionMatch match = gwRegex.match(output);
            
            if (match.hasMatch()) {
                return match.captured(1);
            }
        }
        
        return QString();
    }
    
    void getExternalIP()
    {
        // Get IPv4 external IP
        QProcess *curl4Process = new QProcess(this);
        connect(curl4Process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                this, [this, curl4Process](int exitCode, QProcess::ExitStatus exitStatus) {
                    if (exitStatus == QProcess::NormalExit && exitCode == 0) {
                        QString ipv4 = curl4Process->readAllStandardOutput().trimmed();
                        if (!ipv4.isEmpty()) {
                            externalIPv4 = ipv4;
                        }
                    }
                    curl4Process->deleteLater();
                    
                    // Now get IPv6 external IP
                    getExternalIPv6();
                });
        
        curl4Process->start("curl", QStringList() << "-4" << "-s" << "--max-time" << "5" << "ifconfig.me");
    }
    
    void getExternalIPv6()
    {
        QProcess *curl6Process = new QProcess(this);
        connect(curl6Process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                this, [this, curl6Process](int exitCode, QProcess::ExitStatus exitStatus) {
                    if (exitStatus == QProcess::NormalExit && exitCode == 0) {
                        QString ipv6 = curl6Process->readAllStandardOutput().trimmed();
                        if (!ipv6.isEmpty()) {
                            externalIPv6 = ipv6;
                        }
                    } else if (externalIPv4.isEmpty()) {
                        externalIPv4 = "Unable to retrieve";
                    }
                    
                    // Refresh network table with external IP info
                    if (!externalIPv4.isEmpty() || !externalIPv6.isEmpty()) {
                        loadNetworkInformationFromSystem();
                    }
                    
                    curl6Process->deleteLater();
                });
        
        curl6Process->start("curl", QStringList() << "-6" << "-s" << "--max-time" << "5" << "ifconfig.me");
    }
    
    void loadNetworkInformationFromSystem()
    {
        networkTable->setRowCount(0);
        
        // Get network interfaces and their status
        QMap<QString, NetworkInfo> networkInterfaces = getNetworkInterfaces();
        
        // Get default gateway
        QString defaultGateway = getDefaultGateway();
        
        // Start external IP lookup if not already in progress
        if (externalIPv4.isEmpty() && externalIPv6.isEmpty()) {
            getExternalIP();
        }
        
        int row = 0;
        for (auto it = networkInterfaces.begin(); it != networkInterfaces.end(); ++it) {
            const QString &interface = it.key();
            const NetworkInfo &info = it.value();
            
            networkTable->insertRow(row);
            
            // Interface name
            QTableWidgetItem *interfaceItem = new QTableWidgetItem(interface);
            if (!info.isActive) {
                interfaceItem->setForeground(QColor(128, 128, 128)); // Grey out inactive
                interfaceItem->setFont(QFont("Helvetica", 8, QFont::Normal, true)); // Italic
            }
            networkTable->setItem(row, 0, interfaceItem);
            
            // Status
            QTableWidgetItem *statusItem = new QTableWidgetItem(info.isActive ? "Active" : "Inactive");
            statusItem->setForeground(info.isActive ? QColor(0, 128, 0) : QColor(128, 128, 128));
            if (!info.isActive) {
                statusItem->setFont(QFont("Helvetica", 8, QFont::Normal, true)); // Italic
            }
            networkTable->setItem(row, 1, statusItem);
            
            // IPv4 Address (with external IP if available)
            QString ipv4Text = info.ipv4Address.isEmpty() ? "N/A" : info.ipv4Address;
            if (info.isActive && !externalIPv4.isEmpty() && externalIPv4 != "Unable to retrieve" && !info.ipv4Address.isEmpty()) {
                ipv4Text += "\n(Ext: " + externalIPv4 + ")";
            }
            QTableWidgetItem *ipv4Item = createColoredIPItem(ipv4Text, false, info.isActive && !info.ipv4Address.isEmpty(), true);
            networkTable->setItem(row, 2, ipv4Item);
            
            // IPv6 Address (with external IP if available)
            QString ipv6Text = info.ipv6Address.isEmpty() ? "N/A" : info.ipv6Address;
            if (info.isActive && !externalIPv6.isEmpty() && externalIPv6 != "Unable to retrieve") {
                if (!info.ipv6Address.isEmpty()) {
                    ipv6Text += "\n(Ext: " + externalIPv6 + ")";
                } else {
                    ipv6Text = "(Ext: " + externalIPv6 + ")";
                }
            }
            QTableWidgetItem *ipv6Item = createColoredIPItem(ipv6Text, true, info.isActive && (!info.ipv6Address.isEmpty() || !externalIPv6.isEmpty()), true);
            networkTable->setItem(row, 3, ipv6Item);
            
            // Subnet
            QTableWidgetItem *subnetItem = new QTableWidgetItem(info.subnet.isEmpty() ? "N/A" : info.subnet);
            if (!info.isActive) {
                subnetItem->setForeground(QColor(128, 128, 128));
                subnetItem->setFont(QFont("Helvetica", 8, QFont::Normal, true));
            }
            networkTable->setItem(row, 4, subnetItem);
            
            // Gateway (show default gateway for active interfaces)
            QString gatewayText = info.isActive && !defaultGateway.isEmpty() ? defaultGateway : "N/A";
            QTableWidgetItem *gatewayItem = new QTableWidgetItem(gatewayText);
            if (!info.isActive) {
                gatewayItem->setForeground(QColor(128, 128, 128));
                gatewayItem->setFont(QFont("Helvetica", 8, QFont::Normal, true));
            }
            networkTable->setItem(row, 5, gatewayItem);
            
            // Product (will be filled by lshw data)
            QTableWidgetItem *productItem = new QTableWidgetItem(info.product.isEmpty() ? "Unknown" : info.product);
            if (!info.isActive) {
                productItem->setForeground(QColor(128, 128, 128));
                productItem->setFont(QFont("Helvetica", 8, QFont::Normal, true));
            }
            networkTable->setItem(row, 6, productItem);
            
            // Vendor (will be filled by lshw data)
            QTableWidgetItem *vendorItem = new QTableWidgetItem(info.vendor.isEmpty() ? "Unknown" : info.vendor);
            if (!info.isActive) {
                vendorItem->setForeground(QColor(128, 128, 128));
                vendorItem->setFont(QFont("Helvetica", 8, QFont::Normal, true));
            }
            networkTable->setItem(row, 7, vendorItem);
            
            // Driver
            QTableWidgetItem *driverItem = new QTableWidgetItem(info.driver.isEmpty() ? "Unknown" : info.driver);
            if (!info.isActive) {
                driverItem->setForeground(QColor(128, 128, 128));
                driverItem->setFont(QFont("Helvetica", 8, QFont::Normal, true));
            }
            networkTable->setItem(row, 8, driverItem);
            
            row++;
        }
        
        networkTable->resizeColumnsToContents();
    }
    
    QTableWidgetItem* createColoredIPItem(const QString &ip, bool isIPv6, bool isActive, bool isBold = false)
    {
        QTableWidgetItem *item = new QTableWidgetItem(ip);
        
        if (!isActive || ip == "N/A") {
            item->setForeground(QColor(128, 128, 128));
            item->setFont(QFont("Helvetica", 8, QFont::Normal, true));
        } else {
            if (isIPv6) {
                item->setForeground(QColor(0, 0, 139)); // Dark blue for IPv6
            } else {
                item->setForeground(QColor(0, 128, 0)); // Green for IPv4
            }
            if (isBold) {
                item->setFont(QFont("Helvetica", 8, QFont::Bold));
            } else {
                item->setFont(QFont("Helvetica", 8, QFont::Normal));
            }
        }
        
        return item;
    }

    void loadNetworkInformation(const QJsonObject &item)
    {
        // Always load system network information to ensure fresh data
        loadNetworkInformationFromSystem();
        
        // Update hardware info from lshw data
        QString logicalName = item["logicalname"].toString();
        QString product = item["product"].toString();
        QString vendor = item["vendor"].toString();
        
        // Find existing row with this interface and update it
        for (int row = 0; row < networkTable->rowCount(); row++) {
            QTableWidgetItem *interfaceItem = networkTable->item(row, 0);
            if (interfaceItem && interfaceItem->text() == logicalName) {
                // Update product
                if (!product.isEmpty() && networkTable->item(row, 7)) {
                    networkTable->item(row, 7)->setText(product);
                }
                // Update vendor
                if (!vendor.isEmpty() && networkTable->item(row, 8)) {
                    networkTable->item(row, 8)->setText(vendor);
                }
                break;
            }
        }
    }
    
    void parseShortFormat(const QByteArray &data)
    {
        QString text = QString::fromUtf8(data);
        QStringList lines = text.split('\n', Qt::SkipEmptyParts);
        
        for (const QString &line : lines) {
            if (line.startsWith("H/W path")) continue;
            
            QStringList parts = line.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
            if (parts.size() >= 3) {
                QString device = parts[0];
                QString className = parts[1];
                QString description = parts.mid(2).join(" ");
                
                addRowToTable(allHardwareTable, {className, device, "", "", description});
            }
        }
        
        statusLabel->setText("Hardware information loaded (simplified format)");
    }
    
    void addRowToTable(QTableWidget *table, const QStringList &values)
    {
        int row = table->rowCount();
        table->insertRow(row);
        
        for (int i = 0; i < values.size() && i < table->columnCount(); ++i) {
            table->setItem(row, i, new QTableWidgetItem(values[i]));
        }
    }
    
    void showErrorMessage()
    {
        QMessageBox::information(this, "Install lshw", 
            "To use this application, please install lshw:\n\n"
            "sudo apt install lshw\n\n"
            "After installation, click Refresh to load hardware information.");
    }
    
    void loadOSInformation()
    {
        addPropertyToTable(osTable, "Operating System", QSysInfo::prettyProductName());
        addPropertyToTable(osTable, "Kernel Type", QSysInfo::kernelType());
        addPropertyToTable(osTable, "Kernel Version", QSysInfo::kernelVersion());
        addPropertyToTable(osTable, "Architecture", QSysInfo::currentCpuArchitecture());
        addPropertyToTable(osTable, "Build ABI", QSysInfo::buildAbi());
        addPropertyToTable(osTable, "Hostname", QSysInfo::machineHostName());
        
        QString user = qgetenv("USER");
        if (user.isEmpty()) user = qgetenv("USERNAME");
        addPropertyToTable(osTable, "Current User", user);
        
        QString shell = qgetenv("SHELL");
        addPropertyToTable(osTable, "Default Shell", shell);
        
        QString desktop = qgetenv("XDG_CURRENT_DESKTOP");
        if (desktop.isEmpty()) desktop = qgetenv("DESKTOP_SESSION");
        if (!desktop.isEmpty()) {
            addPropertyToTable(osTable, "Desktop Environment", desktop);
        }
        
        QFile versionFile("/proc/version");
        if (versionFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QString version = versionFile.readAll().trimmed();
            addPropertyToTable(osTable, "Kernel Details", version);
        }
        
        QFile uptimeFile("/proc/uptime");
        if (uptimeFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QString uptimeStr = uptimeFile.readAll().split(' ')[0];
            double uptimeSeconds = uptimeStr.toDouble();
            int days = uptimeSeconds / 86400;
            int hours = (int(uptimeSeconds) % 86400) / 3600;
            int minutes = (int(uptimeSeconds) % 3600) / 60;
            
            QString formattedUptime = QString("%1 days, %2 hours, %3 minutes")
                                     .arg(days).arg(hours).arg(minutes);
            addPropertyToTable(osTable, "System Uptime", formattedUptime);
        }
        
        QFile releaseFile("/etc/os-release");
        if (releaseFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream stream(&releaseFile);
            while (!stream.atEnd()) {
                QString line = stream.readLine();
                if (line.contains('=')) {
                    QStringList parts = line.split('=', Qt::SkipEmptyParts);
                    if (parts.size() >= 2) {
                        QString key = parts[0];
                        QString value = parts[1].remove('"');
                        
                        if (key == "NAME") {
                            addPropertyToTable(osTable, "Distribution", value);
                        } else if (key == "VERSION") {
                            addPropertyToTable(osTable, "Distribution Version", value);
                        } else if (key == "PRETTY_NAME") {
                            addPropertyToTable(osTable, "Full Name", value);
                        }
                    }
                }
            }
        }
        
        QFile memFile("/proc/meminfo");
        if (memFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream stream(&memFile);
            while (!stream.atEnd()) {
                QString line = stream.readLine();
                if (line.startsWith("MemTotal:")) {
                    QString memStr = line.split(QRegularExpression("\\s+"))[1];
                    double memKB = memStr.toDouble();
                    QString memFormatted = formatSize(memKB * 1024);
                    addPropertyToTable(osTable, "Total Memory", memFormatted);
                    break;
                }
            }
        }
        
        QStorageInfo storage = QStorageInfo::root();
        if (storage.isValid()) {
            QString totalSpace = formatSize(storage.bytesTotal());
            QString freeSpace = formatSize(storage.bytesAvailable());
            addPropertyToTable(osTable, "Root Filesystem", storage.rootPath());
            addPropertyToTable(osTable, "Total Disk Space", totalSpace);
            addPropertyToTable(osTable, "Available Disk Space", freeSpace);
        }
    }
    
    void addPropertyToTable(QTableWidget *table, const QString &property, const QString &value)
    {
        if (value.isEmpty()) return;
        
        int row = table->rowCount();
        table->insertRow(row);
        table->setItem(row, 0, new QTableWidgetItem(property));
        table->setItem(row, 1, new QTableWidgetItem(value));
    }
    
    QString formatSize(double bytes)
    {
        if (bytes < 1024) return QString::number(bytes) + " B";
        if (bytes < 1024*1024) return QString::number(bytes/1024, 'f', 1) + " KB";
        if (bytes < 1024*1024*1024) return QString::number(bytes/(1024*1024), 'f', 1) + " MB";
        return QString::number(bytes/(1024*1024*1024), 'f', 1) + " GB";
    }

private:
    QString externalIPv4;
    QString externalIPv6;
    
    QTabWidget *tabWidget;
    QTableWidget *osTable;
    QTableWidget *systemTable;
    QTableWidget *cpuTable;
    QTableWidget *memoryTable;
    QTableWidget *storageTable;
    QTableWidget *networkTable;
    QTableWidget *allHardwareTable;
    
    QPushButton *refreshButton;
    QLineEdit *searchEdit;
    QLabel *statusLabel;
    QProgressBar *progressBar;
};

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    LshwGUI window;
    window.show();
    
    return app.exec();
}

#include "lshwgui.moc"
